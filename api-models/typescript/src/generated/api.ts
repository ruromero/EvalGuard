/* tslint:disable */
/* eslint-disable */
/**
 * EvalGuard Reports API
 * API for accessing and querying model evaluation reports.  This API provides access to evaluation reports stored in the EvalGuard system, allowing clients to retrieve specific reports or query reports by various criteria such as model name, evaluation date, or task type. 
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * Response containing a list of available guardrails
 * @export
 * @interface GuardrailsResponse
 */
export interface GuardrailsResponse {
    /**
     * Array of guardrail definitions
     * @type {Array<Guardrailschema>}
     * @memberof GuardrailsResponse
     */
    'guardrails': Array<Guardrailschema>;
    /**
     * 
     * @type {PaginationInfo}
     * @memberof GuardrailsResponse
     */
    'pagination'?: PaginationInfo;
}
/**
 * A guardrail is a policy or operational constraint that should be applied during  model evaluation or deployment to mitigate risks, enforce quality, or guide behavior.  It can target specific tasks, metrics, or models and is annotated with metadata for  interpretation and traceability. 
 * @export
 * @interface Guardrailschema
 */
export interface Guardrailschema {
    /**
     * Globally unique identifier for the guardrail.
     * @type {string}
     * @memberof Guardrailschema
     */
    'id': string;
    /**
     * Human-readable name of the guardrail.
     * @type {string}
     * @memberof Guardrailschema
     */
    'name': string;
    /**
     * Detailed explanation of the purpose and logic of the guardrail.
     * @type {string}
     * @memberof Guardrailschema
     */
    'description'?: string;
    /**
     * Specifies what the guardrail applies to: tasks, metrics, and/or specific models. 
     * @type {Array<GuardrailschemaTargetsInner>}
     * @memberof Guardrailschema
     */
    'targets': Array<GuardrailschemaTargetsInner>;
    /**
     * Indicates the data flow stage at which the guardrail should be applied: \'input\' for prompt/input constraints, \'output\' for generation constraints,  or \'both\' for end-to-end application. 
     * @type {string}
     * @memberof Guardrailschema
     */
    'scope': GuardrailschemaScopeEnum;
    /**
     * List of external references (e.g., papers, documentation, implementations)  that support or explain the rationale for this guardrail. 
     * @type {Array<string>}
     * @memberof Guardrailschema
     */
    'external_references'?: Array<string>;
    /**
     * Implementation guidance or rule description, written in natural language or  pseudocode for how to enforce this guardrail. 
     * @type {string}
     * @memberof Guardrailschema
     */
    'instructions': string;
}

export const GuardrailschemaScopeEnum = {
    Input: 'input',
    Output: 'output',
    Both: 'both'
} as const;

export type GuardrailschemaScopeEnum = typeof GuardrailschemaScopeEnum[keyof typeof GuardrailschemaScopeEnum];

/**
 * 
 * @export
 * @interface GuardrailschemaTargetsInner
 */
export interface GuardrailschemaTargetsInner {
    /**
     * Task identifier to which the guardrail applies.
     * @type {string}
     * @memberof GuardrailschemaTargetsInner
     */
    'task': string;
    /**
     * List of metric identifiers to which the guardrail applies
     * @type {Array<string>}
     * @memberof GuardrailschemaTargetsInner
     */
    'metrics': Array<string>;
    /**
     * Model identifier this guardrail is scoped to (Optional)
     * @type {string}
     * @memberof GuardrailschemaTargetsInner
     */
    'model'?: string;
}
/**
 * Schema for a metric used to evaluate tasks in model evaluations.
 * @export
 * @interface MetricDefinitionschema
 */
export interface MetricDefinitionschema {
    /**
     * Unique metric identifier, used to link metrics to tasks and reports.
     * @type {string}
     * @memberof MetricDefinitionschema
     */
    'id': string;
    /**
     * Human-readable name of the metric.
     * @type {string}
     * @memberof MetricDefinitionschema
     */
    'name': string;
    /**
     * Detailed description of what the metric measures.
     * @type {string}
     * @memberof MetricDefinitionschema
     */
    'description'?: string;
    /**
     * Type of metric output (percentage, raw score, count, etc.).
     * @type {string}
     * @memberof MetricDefinitionschema
     */
    'type'?: MetricDefinitionschemaTypeEnum;
    /**
     * Indicates whether higher or lower values correspond to better performance.
     * @type {string}
     * @memberof MetricDefinitionschema
     */
    'direction': MetricDefinitionschemaDirectionEnum;
    /**
     * Optional tags describing the metric, e.g., accuracy, robustness, efficiency.
     * @type {Array<string>}
     * @memberof MetricDefinitionschema
     */
    'tags'?: Array<string>;
}

export const MetricDefinitionschemaTypeEnum = {
    Percentage: 'percentage',
    Score: 'score',
    Count: 'count',
    Time: 'time',
    Other: 'other'
} as const;

export type MetricDefinitionschemaTypeEnum = typeof MetricDefinitionschemaTypeEnum[keyof typeof MetricDefinitionschemaTypeEnum];
export const MetricDefinitionschemaDirectionEnum = {
    HigherIsBetter: 'higher_is_better',
    LowerIsBetter: 'lower_is_better'
} as const;

export type MetricDefinitionschemaDirectionEnum = typeof MetricDefinitionschemaDirectionEnum[keyof typeof MetricDefinitionschemaDirectionEnum];

/**
 * Response containing a list of available metrics
 * @export
 * @interface MetricsResponse
 */
export interface MetricsResponse {
    /**
     * Array of metric definitions
     * @type {Array<MetricDefinitionschema>}
     * @memberof MetricsResponse
     */
    'metrics': Array<MetricDefinitionschema>;
    /**
     * 
     * @type {PaginationInfo}
     * @memberof MetricsResponse
     */
    'pagination'?: PaginationInfo;
}
/**
 * Response containing a list of model cards
 * @export
 * @interface ModelCardsResponse
 */
export interface ModelCardsResponse {
    /**
     * Array of model cards
     * @type {Array<ModelCardschema>}
     * @memberof ModelCardsResponse
     */
    'model_cards': Array<ModelCardschema>;
    /**
     * 
     * @type {PaginationInfo}
     * @memberof ModelCardsResponse
     */
    'pagination'?: PaginationInfo;
}
/**
 * A comprehensive model card that includes model identification, evaluation results  with tasks, metrics, thresholds, and recommended guardrails for responsible AI deployment. 
 * @export
 * @interface ModelCardschema
 */
export interface ModelCardschema {
    /**
     * 
     * @type {ModelInfoschema}
     * @memberof ModelCardschema
     */
    'model': ModelInfoschema;
    /**
     * Tasks with their definitions, metrics, and evaluation results. Keys are task identifiers.
     * @type {object}
     * @memberof ModelCardschema
     */
    'tasks': object;
    /**
     * List of recommended guardrails for this model
     * @type {Array<Guardrailschema>}
     * @memberof ModelCardschema
     */
    'guardrails'?: Array<Guardrailschema>;
}
/**
 * Error response
 * @export
 * @interface ModelError
 */
export interface ModelError {
    /**
     * Error message
     * @type {string}
     * @memberof ModelError
     */
    'error': string;
    /**
     * Error code
     * @type {string}
     * @memberof ModelError
     */
    'code'?: string;
    /**
     * Additional error details
     * @type {{ [key: string]: any; }}
     * @memberof ModelError
     */
    'details'?: { [key: string]: any; };
}
/**
 * Information about a model
 * @export
 * @interface ModelInfoschema
 */
export interface ModelInfoschema {
    /**
     * Unique model identifier
     * @type {string}
     * @memberof ModelInfoschema
     */
    'id': string;
    /**
     * Model name
     * @type {string}
     * @memberof ModelInfoschema
     */
    'name': string;
    /**
     * Model namespace or organization
     * @type {string}
     * @memberof ModelInfoschema
     */
    'namespace': string;
    /**
     * List of aliases for the model\'s name. Must not include the namespace.
     * @type {Array<string>}
     * @memberof ModelInfoschema
     */
    'aliases'?: Array<string>;
    /**
     * List of reference links for the model
     * @type {Array<ModelInfoschemaReferenceLinksInner>}
     * @memberof ModelInfoschema
     */
    'reference_links'?: Array<ModelInfoschemaReferenceLinksInner>;
}
/**
 * 
 * @export
 * @interface ModelInfoschemaReferenceLinksInner
 */
export interface ModelInfoschemaReferenceLinksInner {
    /**
     * 
     * @type {string}
     * @memberof ModelInfoschemaReferenceLinksInner
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelInfoschemaReferenceLinksInner
     */
    'url'?: string;
}
/**
 * Response containing a list of available models
 * @export
 * @interface ModelsInfoResponse
 */
export interface ModelsInfoResponse {
    /**
     * Array of model definitions
     * @type {Array<ModelInfoschema>}
     * @memberof ModelsInfoResponse
     */
    'models': Array<ModelInfoschema>;
    /**
     * 
     * @type {PaginationInfo}
     * @memberof ModelsInfoResponse
     */
    'pagination'?: PaginationInfo;
}
/**
 * Pagination information
 * @export
 * @interface PaginationInfo
 */
export interface PaginationInfo {
    /**
     * Total number of items
     * @type {number}
     * @memberof PaginationInfo
     */
    'total': number;
    /**
     * Number of items per page
     * @type {number}
     * @memberof PaginationInfo
     */
    'limit': number;
    /**
     * Number of items skipped
     * @type {number}
     * @memberof PaginationInfo
     */
    'offset': number;
    /**
     * Whether there are more items available
     * @type {boolean}
     * @memberof PaginationInfo
     */
    'has_more': boolean;
}
/**
 * Response containing a list of available policies
 * @export
 * @interface PoliciesResponse
 */
export interface PoliciesResponse {
    /**
     * Array of policy definitions
     * @type {Array<Policyschema>}
     * @memberof PoliciesResponse
     */
    'policies': Array<Policyschema>;
    /**
     * 
     * @type {PaginationInfo}
     * @memberof PoliciesResponse
     */
    'pagination'?: PaginationInfo;
}
/**
 * Schema for a policy used to evaluate tasks in model evaluations.  Policies organize thresholds and guardrails by evaluation context.  Thresholds are embedded within policies, organized by task ID and metric ID. 
 * @export
 * @interface Policyschema
 */
export interface Policyschema {
    /**
     * Unique policy identifier, used to link policies to tasks and reports.
     * @type {string}
     * @memberof Policyschema
     */
    'id': string;
    /**
     * Human-readable name of the policy.
     * @type {string}
     * @memberof Policyschema
     */
    'name': string;
    /**
     * Detailed description of the policy.
     * @type {string}
     * @memberof Policyschema
     */
    'description': string;
    /**
     * Thresholds for the policy, organized by task ID. Each task maps to a TaskThresholds object.
     * @type {object}
     * @memberof Policyschema
     */
    'thresholds'?: object;
}
/**
 * Evaluation report
 * @export
 * @interface ReportResponseItem
 */
export interface ReportResponseItem {
    /**
     * 
     * @type {ReportType}
     * @memberof ReportResponseItem
     */
    'report_type'?: ReportType;
    /**
     * Unique identifier of the report
     * @type {string}
     * @memberof ReportResponseItem
     */
    'id'?: string;
    /**
     * Name of the report
     * @type {string}
     * @memberof ReportResponseItem
     */
    'model_name'?: string;
    /**
     * Namespace of the model
     * @type {string}
     * @memberof ReportResponseItem
     */
    'namespace'?: string;
    /**
     * Timestamp of the report creation
     * @type {string}
     * @memberof ReportResponseItem
     */
    'created_at'?: string;
}


/**
 * Type of the report
 * @export
 * @enum {string}
 */

export const ReportType = {
    LmEval: 'lm-eval'
} as const;

export type ReportType = typeof ReportType[keyof typeof ReportType];


/**
 * Response containing a list of evaluation reports
 * @export
 * @interface ReportsResponse
 */
export interface ReportsResponse {
    /**
     * Collection of evaluation reports
     * @type {Array<ReportResponseItem>}
     * @memberof ReportsResponse
     */
    'reports'?: Array<ReportResponseItem>;
}
/**
 * Schema for a model evaluation task, based on lm-eval report data plus user-added metadata.
 * @export
 * @interface TaskDefinitionschema
 */
export interface TaskDefinitionschema {
    /**
     * Unique task identifier.
     * @type {string}
     * @memberof TaskDefinitionschema
     */
    'id': string;
    /**
     * Human-readable name of the task.
     * @type {string}
     * @memberof TaskDefinitionschema
     */
    'name': string;
    /**
     * Optional detailed description of the task.
     * @type {string}
     * @memberof TaskDefinitionschema
     */
    'description'?: string;
    /**
     * Optional category of the task, e.g. \'question_answering\', \'language_modeling\'.
     * @type {string}
     * @memberof TaskDefinitionschema
     */
    'category'?: string;
    /**
     * Optional tags for the task, e.g. domain, difficulty.
     * @type {Array<string>}
     * @memberof TaskDefinitionschema
     */
    'tags'?: Array<string>;
    /**
     * Optional list of languages relevant to the task.
     * @type {Array<string>}
     * @memberof TaskDefinitionschema
     */
    'languages'?: Array<string>;
}
/**
 * Response containing a list of available tasks
 * @export
 * @interface TasksResponse
 */
export interface TasksResponse {
    /**
     * Array of task definitions
     * @type {Array<{ [key: string]: any; }>}
     * @memberof TasksResponse
     */
    'tasks': Array<{ [key: string]: any; }>;
    /**
     * 
     * @type {PaginationInfo}
     * @memberof TasksResponse
     */
    'pagination'?: PaginationInfo;
}

/**
 * GuardrailsApi - axios parameter creator
 * @export
 */
export const GuardrailsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieve a specific guardrail by its unique identifier. Returns the complete guardrail including target scope, instructions, and metadata. 
         * @summary Get guardrail by ID
         * @param {string} guardrailId Unique identifier of the guardrail
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGuardrail: async (guardrailId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'guardrailId' is not null or undefined
            assertParamExists('getGuardrail', 'guardrailId', guardrailId)
            const localVarPath = `/guardrails/{guardrail_id}`
                .replace(`{${"guardrail_id"}}`, encodeURIComponent(String(guardrailId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a list of guardrails with optional filtering by tasks and metrics. Guardrails are policies or operational constraints that should be applied during  model evaluation or deployment. 
         * @summary List guardrails
         * @param {string} [tasks] Comma-separated list of task identifiers to filter guardrails
         * @param {string} [metrics] Comma-separated list of metric identifiers to filter guardrails
         * @param {number} [limit] Maximum number of items to return
         * @param {number} [offset] Number of items to skip for pagination
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listGuardrails: async (tasks?: string, metrics?: string, limit?: number, offset?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/guardrails`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (tasks !== undefined) {
                localVarQueryParameter['tasks'] = tasks;
            }

            if (metrics !== undefined) {
                localVarQueryParameter['metrics'] = metrics;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * GuardrailsApi - functional programming interface
 * @export
 */
export const GuardrailsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = GuardrailsApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieve a specific guardrail by its unique identifier. Returns the complete guardrail including target scope, instructions, and metadata. 
         * @summary Get guardrail by ID
         * @param {string} guardrailId Unique identifier of the guardrail
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGuardrail(guardrailId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Guardrailschema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGuardrail(guardrailId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GuardrailsApi.getGuardrail']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve a list of guardrails with optional filtering by tasks and metrics. Guardrails are policies or operational constraints that should be applied during  model evaluation or deployment. 
         * @summary List guardrails
         * @param {string} [tasks] Comma-separated list of task identifiers to filter guardrails
         * @param {string} [metrics] Comma-separated list of metric identifiers to filter guardrails
         * @param {number} [limit] Maximum number of items to return
         * @param {number} [offset] Number of items to skip for pagination
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listGuardrails(tasks?: string, metrics?: string, limit?: number, offset?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GuardrailsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listGuardrails(tasks, metrics, limit, offset, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GuardrailsApi.listGuardrails']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * GuardrailsApi - factory interface
 * @export
 */
export const GuardrailsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = GuardrailsApiFp(configuration)
    return {
        /**
         * Retrieve a specific guardrail by its unique identifier. Returns the complete guardrail including target scope, instructions, and metadata. 
         * @summary Get guardrail by ID
         * @param {string} guardrailId Unique identifier of the guardrail
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGuardrail(guardrailId: string, options?: RawAxiosRequestConfig): AxiosPromise<Guardrailschema> {
            return localVarFp.getGuardrail(guardrailId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a list of guardrails with optional filtering by tasks and metrics. Guardrails are policies or operational constraints that should be applied during  model evaluation or deployment. 
         * @summary List guardrails
         * @param {string} [tasks] Comma-separated list of task identifiers to filter guardrails
         * @param {string} [metrics] Comma-separated list of metric identifiers to filter guardrails
         * @param {number} [limit] Maximum number of items to return
         * @param {number} [offset] Number of items to skip for pagination
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listGuardrails(tasks?: string, metrics?: string, limit?: number, offset?: number, options?: RawAxiosRequestConfig): AxiosPromise<GuardrailsResponse> {
            return localVarFp.listGuardrails(tasks, metrics, limit, offset, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * GuardrailsApi - object-oriented interface
 * @export
 * @class GuardrailsApi
 * @extends {BaseAPI}
 */
export class GuardrailsApi extends BaseAPI {
    /**
     * Retrieve a specific guardrail by its unique identifier. Returns the complete guardrail including target scope, instructions, and metadata. 
     * @summary Get guardrail by ID
     * @param {string} guardrailId Unique identifier of the guardrail
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GuardrailsApi
     */
    public getGuardrail(guardrailId: string, options?: RawAxiosRequestConfig) {
        return GuardrailsApiFp(this.configuration).getGuardrail(guardrailId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a list of guardrails with optional filtering by tasks and metrics. Guardrails are policies or operational constraints that should be applied during  model evaluation or deployment. 
     * @summary List guardrails
     * @param {string} [tasks] Comma-separated list of task identifiers to filter guardrails
     * @param {string} [metrics] Comma-separated list of metric identifiers to filter guardrails
     * @param {number} [limit] Maximum number of items to return
     * @param {number} [offset] Number of items to skip for pagination
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GuardrailsApi
     */
    public listGuardrails(tasks?: string, metrics?: string, limit?: number, offset?: number, options?: RawAxiosRequestConfig) {
        return GuardrailsApiFp(this.configuration).listGuardrails(tasks, metrics, limit, offset, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * MetricsApi - axios parameter creator
 * @export
 */
export const MetricsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieve a specific metric by its unique identifier. 
         * @summary Get metric by ID
         * @param {string} metricId Unique identifier of the metric
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMetric: async (metricId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'metricId' is not null or undefined
            assertParamExists('getMetric', 'metricId', metricId)
            const localVarPath = `/metrics/{metric_id}`
                .replace(`{${"metric_id"}}`, encodeURIComponent(String(metricId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a list of all metrics that have evaluation reports in the system. Useful for building metric selection interfaces. 
         * @summary List available metrics
         * @param {number} [limit] Maximum number of items to return
         * @param {number} [offset] Number of items to skip for pagination
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listMetrics: async (limit?: number, offset?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/metrics`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MetricsApi - functional programming interface
 * @export
 */
export const MetricsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MetricsApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieve a specific metric by its unique identifier. 
         * @summary Get metric by ID
         * @param {string} metricId Unique identifier of the metric
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMetric(metricId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MetricDefinitionschema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMetric(metricId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MetricsApi.getMetric']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve a list of all metrics that have evaluation reports in the system. Useful for building metric selection interfaces. 
         * @summary List available metrics
         * @param {number} [limit] Maximum number of items to return
         * @param {number} [offset] Number of items to skip for pagination
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listMetrics(limit?: number, offset?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MetricsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listMetrics(limit, offset, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MetricsApi.listMetrics']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * MetricsApi - factory interface
 * @export
 */
export const MetricsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MetricsApiFp(configuration)
    return {
        /**
         * Retrieve a specific metric by its unique identifier. 
         * @summary Get metric by ID
         * @param {string} metricId Unique identifier of the metric
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMetric(metricId: string, options?: RawAxiosRequestConfig): AxiosPromise<MetricDefinitionschema> {
            return localVarFp.getMetric(metricId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a list of all metrics that have evaluation reports in the system. Useful for building metric selection interfaces. 
         * @summary List available metrics
         * @param {number} [limit] Maximum number of items to return
         * @param {number} [offset] Number of items to skip for pagination
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listMetrics(limit?: number, offset?: number, options?: RawAxiosRequestConfig): AxiosPromise<MetricsResponse> {
            return localVarFp.listMetrics(limit, offset, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MetricsApi - object-oriented interface
 * @export
 * @class MetricsApi
 * @extends {BaseAPI}
 */
export class MetricsApi extends BaseAPI {
    /**
     * Retrieve a specific metric by its unique identifier. 
     * @summary Get metric by ID
     * @param {string} metricId Unique identifier of the metric
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetricsApi
     */
    public getMetric(metricId: string, options?: RawAxiosRequestConfig) {
        return MetricsApiFp(this.configuration).getMetric(metricId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a list of all metrics that have evaluation reports in the system. Useful for building metric selection interfaces. 
     * @summary List available metrics
     * @param {number} [limit] Maximum number of items to return
     * @param {number} [offset] Number of items to skip for pagination
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetricsApi
     */
    public listMetrics(limit?: number, offset?: number, options?: RawAxiosRequestConfig) {
        return MetricsApiFp(this.configuration).listMetrics(limit, offset, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ModelCardsApi - axios parameter creator
 * @export
 */
export const ModelCardsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieve a list of model cards with flexible filtering. Supports filtering by model name, evaluation date range, task type, metrics, dtype, and other criteria. 
         * @summary List model cards
         * @param {string} modelName Filter by model name
         * @param {string} [policyId] Filter by policy ID
         * @param {string} [tasks] Filter by tasks
         * @param {string} [metrics] Filter by metrics
         * @param {number} [limit] Maximum number of items to return
         * @param {number} [offset] Number of items to skip for pagination
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listModelCards: async (modelName: string, policyId?: string, tasks?: string, metrics?: string, limit?: number, offset?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'modelName' is not null or undefined
            assertParamExists('listModelCards', 'modelName', modelName)
            const localVarPath = `/model-cards`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (modelName !== undefined) {
                localVarQueryParameter['model_name'] = modelName;
            }

            if (policyId !== undefined) {
                localVarQueryParameter['policy_id'] = policyId;
            }

            if (tasks !== undefined) {
                localVarQueryParameter['tasks'] = tasks;
            }

            if (metrics !== undefined) {
                localVarQueryParameter['metrics'] = metrics;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ModelCardsApi - functional programming interface
 * @export
 */
export const ModelCardsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ModelCardsApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieve a list of model cards with flexible filtering. Supports filtering by model name, evaluation date range, task type, metrics, dtype, and other criteria. 
         * @summary List model cards
         * @param {string} modelName Filter by model name
         * @param {string} [policyId] Filter by policy ID
         * @param {string} [tasks] Filter by tasks
         * @param {string} [metrics] Filter by metrics
         * @param {number} [limit] Maximum number of items to return
         * @param {number} [offset] Number of items to skip for pagination
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listModelCards(modelName: string, policyId?: string, tasks?: string, metrics?: string, limit?: number, offset?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ModelCardsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listModelCards(modelName, policyId, tasks, metrics, limit, offset, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ModelCardsApi.listModelCards']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ModelCardsApi - factory interface
 * @export
 */
export const ModelCardsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ModelCardsApiFp(configuration)
    return {
        /**
         * Retrieve a list of model cards with flexible filtering. Supports filtering by model name, evaluation date range, task type, metrics, dtype, and other criteria. 
         * @summary List model cards
         * @param {string} modelName Filter by model name
         * @param {string} [policyId] Filter by policy ID
         * @param {string} [tasks] Filter by tasks
         * @param {string} [metrics] Filter by metrics
         * @param {number} [limit] Maximum number of items to return
         * @param {number} [offset] Number of items to skip for pagination
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listModelCards(modelName: string, policyId?: string, tasks?: string, metrics?: string, limit?: number, offset?: number, options?: RawAxiosRequestConfig): AxiosPromise<ModelCardsResponse> {
            return localVarFp.listModelCards(modelName, policyId, tasks, metrics, limit, offset, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ModelCardsApi - object-oriented interface
 * @export
 * @class ModelCardsApi
 * @extends {BaseAPI}
 */
export class ModelCardsApi extends BaseAPI {
    /**
     * Retrieve a list of model cards with flexible filtering. Supports filtering by model name, evaluation date range, task type, metrics, dtype, and other criteria. 
     * @summary List model cards
     * @param {string} modelName Filter by model name
     * @param {string} [policyId] Filter by policy ID
     * @param {string} [tasks] Filter by tasks
     * @param {string} [metrics] Filter by metrics
     * @param {number} [limit] Maximum number of items to return
     * @param {number} [offset] Number of items to skip for pagination
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ModelCardsApi
     */
    public listModelCards(modelName: string, policyId?: string, tasks?: string, metrics?: string, limit?: number, offset?: number, options?: RawAxiosRequestConfig) {
        return ModelCardsApiFp(this.configuration).listModelCards(modelName, policyId, tasks, metrics, limit, offset, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ModelsApi - axios parameter creator
 * @export
 */
export const ModelsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieve a specific model by its unique identifier. 
         * @summary Get model by ID
         * @param {string} modelId Unique identifier of the model
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getModel: async (modelId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'modelId' is not null or undefined
            assertParamExists('getModel', 'modelId', modelId)
            const localVarPath = `/models/{model_id}`
                .replace(`{${"model_id"}}`, encodeURIComponent(String(modelId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a list of all models that have evaluation reports in the system. Useful for building model selection interfaces. 
         * @summary List available models
         * @param {string} [source] Filter by model source/organization
         * @param {number} [limit] Maximum number of items to return
         * @param {number} [offset] Number of items to skip for pagination
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listModels: async (source?: string, limit?: number, offset?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/models`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (source !== undefined) {
                localVarQueryParameter['source'] = source;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ModelsApi - functional programming interface
 * @export
 */
export const ModelsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ModelsApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieve a specific model by its unique identifier. 
         * @summary Get model by ID
         * @param {string} modelId Unique identifier of the model
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getModel(modelId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ModelInfoschema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getModel(modelId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ModelsApi.getModel']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve a list of all models that have evaluation reports in the system. Useful for building model selection interfaces. 
         * @summary List available models
         * @param {string} [source] Filter by model source/organization
         * @param {number} [limit] Maximum number of items to return
         * @param {number} [offset] Number of items to skip for pagination
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listModels(source?: string, limit?: number, offset?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ModelsInfoResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listModels(source, limit, offset, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ModelsApi.listModels']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ModelsApi - factory interface
 * @export
 */
export const ModelsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ModelsApiFp(configuration)
    return {
        /**
         * Retrieve a specific model by its unique identifier. 
         * @summary Get model by ID
         * @param {string} modelId Unique identifier of the model
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getModel(modelId: string, options?: RawAxiosRequestConfig): AxiosPromise<ModelInfoschema> {
            return localVarFp.getModel(modelId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a list of all models that have evaluation reports in the system. Useful for building model selection interfaces. 
         * @summary List available models
         * @param {string} [source] Filter by model source/organization
         * @param {number} [limit] Maximum number of items to return
         * @param {number} [offset] Number of items to skip for pagination
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listModels(source?: string, limit?: number, offset?: number, options?: RawAxiosRequestConfig): AxiosPromise<ModelsInfoResponse> {
            return localVarFp.listModels(source, limit, offset, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ModelsApi - object-oriented interface
 * @export
 * @class ModelsApi
 * @extends {BaseAPI}
 */
export class ModelsApi extends BaseAPI {
    /**
     * Retrieve a specific model by its unique identifier. 
     * @summary Get model by ID
     * @param {string} modelId Unique identifier of the model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ModelsApi
     */
    public getModel(modelId: string, options?: RawAxiosRequestConfig) {
        return ModelsApiFp(this.configuration).getModel(modelId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a list of all models that have evaluation reports in the system. Useful for building model selection interfaces. 
     * @summary List available models
     * @param {string} [source] Filter by model source/organization
     * @param {number} [limit] Maximum number of items to return
     * @param {number} [offset] Number of items to skip for pagination
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ModelsApi
     */
    public listModels(source?: string, limit?: number, offset?: number, options?: RawAxiosRequestConfig) {
        return ModelsApiFp(this.configuration).listModels(source, limit, offset, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * PoliciesApi - axios parameter creator
 * @export
 */
export const PoliciesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieve a specific policy by its unique identifier. 
         * @summary Get policy by ID
         * @param {string} policyId Unique identifier of the policy
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPolicy: async (policyId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'policyId' is not null or undefined
            assertParamExists('getPolicy', 'policyId', policyId)
            const localVarPath = `/policies/{policy_id}`
                .replace(`{${"policy_id"}}`, encodeURIComponent(String(policyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a list of all policies available in the system. 
         * @summary List available policies
         * @param {number} [limit] Maximum number of items to return
         * @param {number} [offset] Number of items to skip for pagination
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPolicies: async (limit?: number, offset?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/policies`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PoliciesApi - functional programming interface
 * @export
 */
export const PoliciesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PoliciesApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieve a specific policy by its unique identifier. 
         * @summary Get policy by ID
         * @param {string} policyId Unique identifier of the policy
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPolicy(policyId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Policyschema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPolicy(policyId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PoliciesApi.getPolicy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve a list of all policies available in the system. 
         * @summary List available policies
         * @param {number} [limit] Maximum number of items to return
         * @param {number} [offset] Number of items to skip for pagination
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listPolicies(limit?: number, offset?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PoliciesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listPolicies(limit, offset, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PoliciesApi.listPolicies']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * PoliciesApi - factory interface
 * @export
 */
export const PoliciesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PoliciesApiFp(configuration)
    return {
        /**
         * Retrieve a specific policy by its unique identifier. 
         * @summary Get policy by ID
         * @param {string} policyId Unique identifier of the policy
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPolicy(policyId: string, options?: RawAxiosRequestConfig): AxiosPromise<Policyschema> {
            return localVarFp.getPolicy(policyId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a list of all policies available in the system. 
         * @summary List available policies
         * @param {number} [limit] Maximum number of items to return
         * @param {number} [offset] Number of items to skip for pagination
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPolicies(limit?: number, offset?: number, options?: RawAxiosRequestConfig): AxiosPromise<PoliciesResponse> {
            return localVarFp.listPolicies(limit, offset, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PoliciesApi - object-oriented interface
 * @export
 * @class PoliciesApi
 * @extends {BaseAPI}
 */
export class PoliciesApi extends BaseAPI {
    /**
     * Retrieve a specific policy by its unique identifier. 
     * @summary Get policy by ID
     * @param {string} policyId Unique identifier of the policy
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PoliciesApi
     */
    public getPolicy(policyId: string, options?: RawAxiosRequestConfig) {
        return PoliciesApiFp(this.configuration).getPolicy(policyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a list of all policies available in the system. 
     * @summary List available policies
     * @param {number} [limit] Maximum number of items to return
     * @param {number} [offset] Number of items to skip for pagination
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PoliciesApi
     */
    public listPolicies(limit?: number, offset?: number, options?: RawAxiosRequestConfig) {
        return PoliciesApiFp(this.configuration).listPolicies(limit, offset, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ReportsApi - axios parameter creator
 * @export
 */
export const ReportsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieve a specific evaluation report by its unique identifier. Returns the complete report including context, tasks, and results. 
         * @summary Get evaluation report by ID
         * @param {string} namespace Namespace of the model
         * @param {string} modelName Name of the model
         * @param {string} reportId Unique identifier of the report
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReport: async (namespace: string, modelName: string, reportId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'namespace' is not null or undefined
            assertParamExists('getReport', 'namespace', namespace)
            // verify required parameter 'modelName' is not null or undefined
            assertParamExists('getReport', 'modelName', modelName)
            // verify required parameter 'reportId' is not null or undefined
            assertParamExists('getReport', 'reportId', reportId)
            const localVarPath = `/reports/{namespace}/{model_name}/lm-eval/{report_id}`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"model_name"}}`, encodeURIComponent(String(modelName)))
                .replace(`{${"report_id"}}`, encodeURIComponent(String(reportId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a list of all evaluation reports for a specific model. 
         * @summary List evaluation reports for a model
         * @param {string} namespace Namespace of the model
         * @param {string} modelName Name of the model
         * @param {ReportType} [reportType] Type of report
         * @param {number} [limit] Maximum number of items to return
         * @param {number} [offset] Number of items to skip for pagination
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listReports: async (namespace: string, modelName: string, reportType?: ReportType, limit?: number, offset?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'namespace' is not null or undefined
            assertParamExists('listReports', 'namespace', namespace)
            // verify required parameter 'modelName' is not null or undefined
            assertParamExists('listReports', 'modelName', modelName)
            const localVarPath = `/reports/{namespace}/{model_name}`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"model_name"}}`, encodeURIComponent(String(modelName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (reportType !== undefined) {
                localVarQueryParameter['report_type'] = reportType;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ReportsApi - functional programming interface
 * @export
 */
export const ReportsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ReportsApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieve a specific evaluation report by its unique identifier. Returns the complete report including context, tasks, and results. 
         * @summary Get evaluation report by ID
         * @param {string} namespace Namespace of the model
         * @param {string} modelName Name of the model
         * @param {string} reportId Unique identifier of the report
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getReport(namespace: string, modelName: string, reportId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getReport(namespace, modelName, reportId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ReportsApi.getReport']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve a list of all evaluation reports for a specific model. 
         * @summary List evaluation reports for a model
         * @param {string} namespace Namespace of the model
         * @param {string} modelName Name of the model
         * @param {ReportType} [reportType] Type of report
         * @param {number} [limit] Maximum number of items to return
         * @param {number} [offset] Number of items to skip for pagination
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listReports(namespace: string, modelName: string, reportType?: ReportType, limit?: number, offset?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReportsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listReports(namespace, modelName, reportType, limit, offset, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ReportsApi.listReports']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ReportsApi - factory interface
 * @export
 */
export const ReportsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ReportsApiFp(configuration)
    return {
        /**
         * Retrieve a specific evaluation report by its unique identifier. Returns the complete report including context, tasks, and results. 
         * @summary Get evaluation report by ID
         * @param {string} namespace Namespace of the model
         * @param {string} modelName Name of the model
         * @param {string} reportId Unique identifier of the report
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReport(namespace: string, modelName: string, reportId: string, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.getReport(namespace, modelName, reportId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a list of all evaluation reports for a specific model. 
         * @summary List evaluation reports for a model
         * @param {string} namespace Namespace of the model
         * @param {string} modelName Name of the model
         * @param {ReportType} [reportType] Type of report
         * @param {number} [limit] Maximum number of items to return
         * @param {number} [offset] Number of items to skip for pagination
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listReports(namespace: string, modelName: string, reportType?: ReportType, limit?: number, offset?: number, options?: RawAxiosRequestConfig): AxiosPromise<ReportsResponse> {
            return localVarFp.listReports(namespace, modelName, reportType, limit, offset, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ReportsApi - object-oriented interface
 * @export
 * @class ReportsApi
 * @extends {BaseAPI}
 */
export class ReportsApi extends BaseAPI {
    /**
     * Retrieve a specific evaluation report by its unique identifier. Returns the complete report including context, tasks, and results. 
     * @summary Get evaluation report by ID
     * @param {string} namespace Namespace of the model
     * @param {string} modelName Name of the model
     * @param {string} reportId Unique identifier of the report
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReportsApi
     */
    public getReport(namespace: string, modelName: string, reportId: string, options?: RawAxiosRequestConfig) {
        return ReportsApiFp(this.configuration).getReport(namespace, modelName, reportId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a list of all evaluation reports for a specific model. 
     * @summary List evaluation reports for a model
     * @param {string} namespace Namespace of the model
     * @param {string} modelName Name of the model
     * @param {ReportType} [reportType] Type of report
     * @param {number} [limit] Maximum number of items to return
     * @param {number} [offset] Number of items to skip for pagination
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReportsApi
     */
    public listReports(namespace: string, modelName: string, reportType?: ReportType, limit?: number, offset?: number, options?: RawAxiosRequestConfig) {
        return ReportsApiFp(this.configuration).listReports(namespace, modelName, reportType, limit, offset, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * TasksApi - axios parameter creator
 * @export
 */
export const TasksApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieve a specific task by its unique identifier. 
         * @summary Get task by ID
         * @param {string} taskId Unique identifier of the task
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTask: async (taskId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'taskId' is not null or undefined
            assertParamExists('getTask', 'taskId', taskId)
            const localVarPath = `/tasks/{task_id}`
                .replace(`{${"task_id"}}`, encodeURIComponent(String(taskId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a list of all evaluation tasks available in the system. Useful for building task selection interfaces. 
         * @summary List available tasks
         * @param {number} [limit] Maximum number of items to return
         * @param {number} [offset] Number of items to skip for pagination
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTasks: async (limit?: number, offset?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/tasks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TasksApi - functional programming interface
 * @export
 */
export const TasksApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TasksApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieve a specific task by its unique identifier. 
         * @summary Get task by ID
         * @param {string} taskId Unique identifier of the task
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTask(taskId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TaskDefinitionschema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTask(taskId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TasksApi.getTask']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve a list of all evaluation tasks available in the system. Useful for building task selection interfaces. 
         * @summary List available tasks
         * @param {number} [limit] Maximum number of items to return
         * @param {number} [offset] Number of items to skip for pagination
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listTasks(limit?: number, offset?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TasksResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listTasks(limit, offset, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TasksApi.listTasks']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * TasksApi - factory interface
 * @export
 */
export const TasksApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TasksApiFp(configuration)
    return {
        /**
         * Retrieve a specific task by its unique identifier. 
         * @summary Get task by ID
         * @param {string} taskId Unique identifier of the task
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTask(taskId: string, options?: RawAxiosRequestConfig): AxiosPromise<TaskDefinitionschema> {
            return localVarFp.getTask(taskId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a list of all evaluation tasks available in the system. Useful for building task selection interfaces. 
         * @summary List available tasks
         * @param {number} [limit] Maximum number of items to return
         * @param {number} [offset] Number of items to skip for pagination
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTasks(limit?: number, offset?: number, options?: RawAxiosRequestConfig): AxiosPromise<TasksResponse> {
            return localVarFp.listTasks(limit, offset, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TasksApi - object-oriented interface
 * @export
 * @class TasksApi
 * @extends {BaseAPI}
 */
export class TasksApi extends BaseAPI {
    /**
     * Retrieve a specific task by its unique identifier. 
     * @summary Get task by ID
     * @param {string} taskId Unique identifier of the task
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TasksApi
     */
    public getTask(taskId: string, options?: RawAxiosRequestConfig) {
        return TasksApiFp(this.configuration).getTask(taskId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a list of all evaluation tasks available in the system. Useful for building task selection interfaces. 
     * @summary List available tasks
     * @param {number} [limit] Maximum number of items to return
     * @param {number} [offset] Number of items to skip for pagination
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TasksApi
     */
    public listTasks(limit?: number, offset?: number, options?: RawAxiosRequestConfig) {
        return TasksApiFp(this.configuration).listTasks(limit, offset, options).then((request) => request(this.axios, this.basePath));
    }
}



