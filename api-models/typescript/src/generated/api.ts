/* tslint:disable */
/* eslint-disable */
/**
 * EvalGuard Reports API
 * API for accessing and querying model evaluation reports.  This API provides access to evaluation reports stored in the EvalGuard system, allowing clients to retrieve specific reports or query reports by various criteria such as model name, evaluation date, or task type. 
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * Response containing a list of available guardrails
 * @export
 * @interface GuardrailsResponse
 */
export interface GuardrailsResponse {
    /**
     * Array of guardrail definitions
     * @type {Array<Guardrailschema>}
     * @memberof GuardrailsResponse
     */
    'guardrails': Array<Guardrailschema>;
    /**
     * 
     * @type {PaginationInfo}
     * @memberof GuardrailsResponse
     */
    'pagination'?: PaginationInfo;
}
/**
 * A guardrail is a policy or operational constraint that should be applied during  model evaluation or deployment to mitigate risks, enforce quality, or guide behavior.  It can target specific tasks, metrics, or models and is annotated with metadata for  interpretation and traceability. 
 * @export
 * @interface Guardrailschema
 */
export interface Guardrailschema {
    /**
     * Globally unique identifier for the guardrail.
     * @type {string}
     * @memberof Guardrailschema
     */
    'id': string;
    /**
     * Human-readable name of the guardrail.
     * @type {string}
     * @memberof Guardrailschema
     */
    'name': string;
    /**
     * Detailed explanation of the purpose and logic of the guardrail.
     * @type {string}
     * @memberof Guardrailschema
     */
    'description'?: string;
    /**
     * Specifies what the guardrail applies to: tasks, metrics, and/or specific models. 
     * @type {Array<GuardrailschemaTargetsInner>}
     * @memberof Guardrailschema
     */
    'targets': Array<GuardrailschemaTargetsInner>;
    /**
     * Indicates the data flow stage at which the guardrail should be applied: \'input\' for prompt/input constraints, \'output\' for generation constraints,  or \'both\' for end-to-end application. 
     * @type {string}
     * @memberof Guardrailschema
     */
    'scope': GuardrailschemaScopeEnum;
    /**
     * List of external references (e.g., papers, documentation, implementations)  that support or explain the rationale for this guardrail. 
     * @type {Array<string>}
     * @memberof Guardrailschema
     */
    'external_references'?: Array<string>;
    /**
     * Implementation guidance or rule description, written in natural language or  pseudocode for how to enforce this guardrail. 
     * @type {string}
     * @memberof Guardrailschema
     */
    'instructions': string;
}

export const GuardrailschemaScopeEnum = {
    Input: 'input',
    Output: 'output',
    Both: 'both'
} as const;

export type GuardrailschemaScopeEnum = typeof GuardrailschemaScopeEnum[keyof typeof GuardrailschemaScopeEnum];

/**
 * 
 * @export
 * @interface GuardrailschemaTargetsInner
 */
export interface GuardrailschemaTargetsInner {
    /**
     * Task identifier to which the guardrail applies.
     * @type {string}
     * @memberof GuardrailschemaTargetsInner
     */
    'task': string;
    /**
     * List of metric identifiers to which the guardrail applies
     * @type {Array<string>}
     * @memberof GuardrailschemaTargetsInner
     */
    'metrics': Array<string>;
    /**
     * Model identifier this guardrail is scoped to (Optional)
     * @type {string}
     * @memberof GuardrailschemaTargetsInner
     */
    'model'?: string;
}
/**
 * Schema for a metric used to evaluate tasks in model evaluations.
 * @export
 * @interface MetricDefinitionschema
 */
export interface MetricDefinitionschema {
    /**
     * Unique metric identifier, used to link metrics to tasks and reports.
     * @type {string}
     * @memberof MetricDefinitionschema
     */
    'id': string;
    /**
     * Human-readable name of the metric.
     * @type {string}
     * @memberof MetricDefinitionschema
     */
    'name': string;
    /**
     * Detailed description of what the metric measures.
     * @type {string}
     * @memberof MetricDefinitionschema
     */
    'description'?: string;
    /**
     * Type of metric output (percentage, raw score, count, etc.).
     * @type {string}
     * @memberof MetricDefinitionschema
     */
    'type'?: MetricDefinitionschemaTypeEnum;
    /**
     * Indicates whether higher or lower values correspond to better performance.
     * @type {string}
     * @memberof MetricDefinitionschema
     */
    'direction': MetricDefinitionschemaDirectionEnum;
    /**
     * Optional tags describing the metric, e.g., accuracy, robustness, efficiency.
     * @type {Array<string>}
     * @memberof MetricDefinitionschema
     */
    'tags'?: Array<string>;
}

export const MetricDefinitionschemaTypeEnum = {
    Percentage: 'percentage',
    Score: 'score',
    Count: 'count',
    Time: 'time',
    Other: 'other'
} as const;

export type MetricDefinitionschemaTypeEnum = typeof MetricDefinitionschemaTypeEnum[keyof typeof MetricDefinitionschemaTypeEnum];
export const MetricDefinitionschemaDirectionEnum = {
    HigherIsBetter: 'higher_is_better',
    LowerIsBetter: 'lower_is_better'
} as const;

export type MetricDefinitionschemaDirectionEnum = typeof MetricDefinitionschemaDirectionEnum[keyof typeof MetricDefinitionschemaDirectionEnum];

/**
 * Response containing a list of available metrics
 * @export
 * @interface MetricsResponse
 */
export interface MetricsResponse {
    /**
     * Array of metric definitions
     * @type {Array<MetricDefinitionschema>}
     * @memberof MetricsResponse
     */
    'metrics': Array<MetricDefinitionschema>;
    /**
     * 
     * @type {PaginationInfo}
     * @memberof MetricsResponse
     */
    'pagination'?: PaginationInfo;
}
/**
 * Response containing a list of model cards
 * @export
 * @interface ModelCardsResponse
 */
export interface ModelCardsResponse {
    /**
     * Array of model cards
     * @type {Array<ModelCardschema>}
     * @memberof ModelCardsResponse
     */
    'model_cards': Array<ModelCardschema>;
    /**
     * 
     * @type {PaginationInfo}
     * @memberof ModelCardsResponse
     */
    'pagination'?: PaginationInfo;
}
/**
 * A comprehensive model card that includes model identification, evaluation results  with tasks, metrics, thresholds, and recommended guardrails for responsible AI deployment. 
 * @export
 * @interface ModelCardschema
 */
export interface ModelCardschema {
    /**
     * 
     * @type {ModelInfoschema}
     * @memberof ModelCardschema
     */
    'model': ModelInfoschema;
    /**
     * Tasks with their definitions, metrics, and evaluation results. Keys are task identifiers.
     * @type {object}
     * @memberof ModelCardschema
     */
    'tasks': object;
    /**
     * List of recommended guardrails for this model
     * @type {Array<Guardrailschema>}
     * @memberof ModelCardschema
     */
    'guardrails'?: Array<Guardrailschema>;
}
/**
 * Error response
 * @export
 * @interface ModelError
 */
export interface ModelError {
    /**
     * Error message
     * @type {string}
     * @memberof ModelError
     */
    'error': string;
    /**
     * Error code
     * @type {string}
     * @memberof ModelError
     */
    'code'?: string;
    /**
     * Additional error details
     * @type {{ [key: string]: any; }}
     * @memberof ModelError
     */
    'details'?: { [key: string]: any; };
}
/**
 * Information about a model
 * @export
 * @interface ModelInfoschema
 */
export interface ModelInfoschema {
    /**
     * Unique model identifier
     * @type {string}
     * @memberof ModelInfoschema
     */
    'id': string;
    /**
     * Model name
     * @type {string}
     * @memberof ModelInfoschema
     */
    'name': string;
    /**
     * Model namespace or organization
     * @type {string}
     * @memberof ModelInfoschema
     */
    'namespace': string;
    /**
     * List of aliases for the model\'s name. Must not include the namespace.
     * @type {Array<string>}
     * @memberof ModelInfoschema
     */
    'aliases'?: Array<string>;
    /**
     * List of reference links for the model
     * @type {Array<ModelInfoschemaReferenceLinksInner>}
     * @memberof ModelInfoschema
     */
    'reference_links'?: Array<ModelInfoschemaReferenceLinksInner>;
}
/**
 * 
 * @export
 * @interface ModelInfoschemaReferenceLinksInner
 */
export interface ModelInfoschemaReferenceLinksInner {
    /**
     * 
     * @type {string}
     * @memberof ModelInfoschemaReferenceLinksInner
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelInfoschemaReferenceLinksInner
     */
    'url'?: string;
}
/**
 * Response containing a list of available models
 * @export
 * @interface ModelsInfoResponse
 */
export interface ModelsInfoResponse {
    /**
     * Array of model definitions
     * @type {Array<ModelInfoschema>}
     * @memberof ModelsInfoResponse
     */
    'models': Array<ModelInfoschema>;
    /**
     * 
     * @type {PaginationInfo}
     * @memberof ModelsInfoResponse
     */
    'pagination'?: PaginationInfo;
}
/**
 * Pagination information
 * @export
 * @interface PaginationInfo
 */
export interface PaginationInfo {
    /**
     * Total number of items
     * @type {number}
     * @memberof PaginationInfo
     */
    'total': number;
    /**
     * Number of items per page
     * @type {number}
     * @memberof PaginationInfo
     */
    'limit': number;
    /**
     * Number of items skipped
     * @type {number}
     * @memberof PaginationInfo
     */
    'offset': number;
    /**
     * Whether there are more items available
     * @type {boolean}
     * @memberof PaginationInfo
     */
    'has_more': boolean;
}
/**
 * Schema for a report of model evaluation results.
 * @export
 * @interface Reportschema
 */
export interface Reportschema {
    /**
     * Unique report identifier.
     * @type {string}
     * @memberof Reportschema
     */
    'id'?: string;
    /**
     * Flexible key-value metadata about the report generation.
     * @type {{ [key: string]: string; }}
     * @memberof Reportschema
     */
    'metadata'?: { [key: string]: string; };
    /**
     * 
     * @type {ReportschemaContext}
     * @memberof Reportschema
     */
    'context'?: ReportschemaContext;
    /**
     * List of tasks in the report. The keys are the task names.
     * @type {Array<object>}
     * @memberof Reportschema
     */
    'tasks'?: Array<object>;
    /**
     * List of results in the report. The keys are the metric names.
     * @type {Array<object>}
     * @memberof Reportschema
     */
    'results'?: Array<object>;
}
/**
 * Contextual information about the report generation.
 * @export
 * @interface ReportschemaContext
 */
export interface ReportschemaContext {
    /**
     * Name of the model being evaluated.
     * @type {string}
     * @memberof ReportschemaContext
     */
    'model_name'?: string;
    /**
     * Version of the model being evaluated.
     * @type {string}
     * @memberof ReportschemaContext
     */
    'model_source'?: string;
    /**
     * Git hash of the model being evaluated.
     * @type {string}
     * @memberof ReportschemaContext
     */
    'git_hash'?: string;
    /**
     * Timestamp of the report generation.
     * @type {number}
     * @memberof ReportschemaContext
     */
    'date'?: number;
    /**
     * 
     * @type {ReportschemaContextExecution}
     * @memberof ReportschemaContext
     */
    'execution'?: ReportschemaContextExecution;
    /**
     * 
     * @type {ReportschemaContextTools}
     * @memberof ReportschemaContext
     */
    'tools'?: ReportschemaContextTools;
}
/**
 * Execution information about the report generation.
 * @export
 * @interface ReportschemaContextExecution
 */
export interface ReportschemaContextExecution {
    /**
     * Arguments used to instantiate the model.
     * @type {string}
     * @memberof ReportschemaContextExecution
     */
    'model_args_plain'?: string;
    /**
     * Arguments used to instantiate the model.
     * @type {{ [key: string]: string; }}
     * @memberof ReportschemaContextExecution
     */
    'model_args_dict'?: { [key: string]: string; };
}
/**
 * Tools used to generate the report.
 * @export
 * @interface ReportschemaContextTools
 */
export interface ReportschemaContextTools {
    /**
     * 
     * @type {ReportschemaContextToolsLmEval}
     * @memberof ReportschemaContextTools
     */
    'lm_eval'?: ReportschemaContextToolsLmEval;
    /**
     * 
     * @type {ReportschemaContextToolsTransformers}
     * @memberof ReportschemaContextTools
     */
    'transformers'?: ReportschemaContextToolsTransformers;
}
/**
 * lm-eval library used to generate the report.
 * @export
 * @interface ReportschemaContextToolsLmEval
 */
export interface ReportschemaContextToolsLmEval {
    /**
     * 
     * @type {string}
     * @memberof ReportschemaContextToolsLmEval
     */
    'version'?: string;
}
/**
 * Transformers library used to generate the report.
 * @export
 * @interface ReportschemaContextToolsTransformers
 */
export interface ReportschemaContextToolsTransformers {
    /**
     * 
     * @type {string}
     * @memberof ReportschemaContextToolsTransformers
     */
    'version'?: string;
}
/**
 * Schema for a model evaluation task, based on lm-eval report data plus user-added metadata.
 * @export
 * @interface TaskDefinitionschema
 */
export interface TaskDefinitionschema {
    /**
     * Unique task identifier.
     * @type {string}
     * @memberof TaskDefinitionschema
     */
    'id': string;
    /**
     * Human-readable name of the task.
     * @type {string}
     * @memberof TaskDefinitionschema
     */
    'name': string;
    /**
     * Optional detailed description of the task.
     * @type {string}
     * @memberof TaskDefinitionschema
     */
    'description'?: string;
    /**
     * Optional category of the task, e.g. \'question_answering\', \'language_modeling\'.
     * @type {string}
     * @memberof TaskDefinitionschema
     */
    'category'?: string;
    /**
     * Optional tags for the task, e.g. domain, difficulty.
     * @type {Array<string>}
     * @memberof TaskDefinitionschema
     */
    'tags'?: Array<string>;
    /**
     * Optional list of languages relevant to the task.
     * @type {Array<string>}
     * @memberof TaskDefinitionschema
     */
    'languages'?: Array<string>;
}
/**
 * Response containing a list of available tasks
 * @export
 * @interface TasksResponse
 */
export interface TasksResponse {
    /**
     * Array of task definitions
     * @type {Array<{ [key: string]: any; }>}
     * @memberof TasksResponse
     */
    'tasks': Array<{ [key: string]: any; }>;
    /**
     * 
     * @type {PaginationInfo}
     * @memberof TasksResponse
     */
    'pagination'?: PaginationInfo;
}
/**
 * Response containing thresholds for specified tasks
 * @export
 * @interface ThresholdsResponse
 */
export interface ThresholdsResponse {
    /**
     * Array of threshold definitions
     * @type {Array<Thresholdschema>}
     * @memberof ThresholdsResponse
     */
    'thresholds': Array<Thresholdschema>;
    /**
     * 
     * @type {PaginationInfo}
     * @memberof ThresholdsResponse
     */
    'pagination'?: PaginationInfo;
}
/**
 * Schema to define interpretation thresholds for metric scores within a task context.
 * @export
 * @interface Thresholdschema
 */
export interface Thresholdschema {
    /**
     * Task ID to which these thresholds apply.
     * @type {string}
     * @memberof Thresholdschema
     */
    'task': string;
    /**
     * Mapping from metric IDs to arrays of threshold ranges and labels.
     * @type {object}
     * @memberof Thresholdschema
     */
    'thresholds': object;
}

/**
 * GuardrailsApi - axios parameter creator
 * @export
 */
export const GuardrailsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieve a specific guardrail by its unique identifier. Returns the complete guardrail including target scope, instructions, and metadata. 
         * @summary Get guardrail by ID
         * @param {string} guardrailId Unique identifier of the guardrail
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGuardrail: async (guardrailId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'guardrailId' is not null or undefined
            assertParamExists('getGuardrail', 'guardrailId', guardrailId)
            const localVarPath = `/guardrails/{guardrail_id}`
                .replace(`{${"guardrail_id"}}`, encodeURIComponent(String(guardrailId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a list of guardrails with optional filtering by tasks and metrics. Guardrails are policies or operational constraints that should be applied during  model evaluation or deployment. 
         * @summary List guardrails
         * @param {string} [tasks] Comma-separated list of task identifiers to filter guardrails
         * @param {string} [metrics] Comma-separated list of metric identifiers to filter guardrails
         * @param {number} [limit] Maximum number of items to return
         * @param {number} [offset] Number of items to skip for pagination
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listGuardrails: async (tasks?: string, metrics?: string, limit?: number, offset?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/guardrails`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (tasks !== undefined) {
                localVarQueryParameter['tasks'] = tasks;
            }

            if (metrics !== undefined) {
                localVarQueryParameter['metrics'] = metrics;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * GuardrailsApi - functional programming interface
 * @export
 */
export const GuardrailsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = GuardrailsApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieve a specific guardrail by its unique identifier. Returns the complete guardrail including target scope, instructions, and metadata. 
         * @summary Get guardrail by ID
         * @param {string} guardrailId Unique identifier of the guardrail
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGuardrail(guardrailId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Guardrailschema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGuardrail(guardrailId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GuardrailsApi.getGuardrail']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve a list of guardrails with optional filtering by tasks and metrics. Guardrails are policies or operational constraints that should be applied during  model evaluation or deployment. 
         * @summary List guardrails
         * @param {string} [tasks] Comma-separated list of task identifiers to filter guardrails
         * @param {string} [metrics] Comma-separated list of metric identifiers to filter guardrails
         * @param {number} [limit] Maximum number of items to return
         * @param {number} [offset] Number of items to skip for pagination
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listGuardrails(tasks?: string, metrics?: string, limit?: number, offset?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GuardrailsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listGuardrails(tasks, metrics, limit, offset, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GuardrailsApi.listGuardrails']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * GuardrailsApi - factory interface
 * @export
 */
export const GuardrailsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = GuardrailsApiFp(configuration)
    return {
        /**
         * Retrieve a specific guardrail by its unique identifier. Returns the complete guardrail including target scope, instructions, and metadata. 
         * @summary Get guardrail by ID
         * @param {string} guardrailId Unique identifier of the guardrail
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGuardrail(guardrailId: string, options?: RawAxiosRequestConfig): AxiosPromise<Guardrailschema> {
            return localVarFp.getGuardrail(guardrailId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a list of guardrails with optional filtering by tasks and metrics. Guardrails are policies or operational constraints that should be applied during  model evaluation or deployment. 
         * @summary List guardrails
         * @param {string} [tasks] Comma-separated list of task identifiers to filter guardrails
         * @param {string} [metrics] Comma-separated list of metric identifiers to filter guardrails
         * @param {number} [limit] Maximum number of items to return
         * @param {number} [offset] Number of items to skip for pagination
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listGuardrails(tasks?: string, metrics?: string, limit?: number, offset?: number, options?: RawAxiosRequestConfig): AxiosPromise<GuardrailsResponse> {
            return localVarFp.listGuardrails(tasks, metrics, limit, offset, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * GuardrailsApi - object-oriented interface
 * @export
 * @class GuardrailsApi
 * @extends {BaseAPI}
 */
export class GuardrailsApi extends BaseAPI {
    /**
     * Retrieve a specific guardrail by its unique identifier. Returns the complete guardrail including target scope, instructions, and metadata. 
     * @summary Get guardrail by ID
     * @param {string} guardrailId Unique identifier of the guardrail
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GuardrailsApi
     */
    public getGuardrail(guardrailId: string, options?: RawAxiosRequestConfig) {
        return GuardrailsApiFp(this.configuration).getGuardrail(guardrailId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a list of guardrails with optional filtering by tasks and metrics. Guardrails are policies or operational constraints that should be applied during  model evaluation or deployment. 
     * @summary List guardrails
     * @param {string} [tasks] Comma-separated list of task identifiers to filter guardrails
     * @param {string} [metrics] Comma-separated list of metric identifiers to filter guardrails
     * @param {number} [limit] Maximum number of items to return
     * @param {number} [offset] Number of items to skip for pagination
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GuardrailsApi
     */
    public listGuardrails(tasks?: string, metrics?: string, limit?: number, offset?: number, options?: RawAxiosRequestConfig) {
        return GuardrailsApiFp(this.configuration).listGuardrails(tasks, metrics, limit, offset, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * MetricsApi - axios parameter creator
 * @export
 */
export const MetricsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieve a specific metric by its unique identifier. 
         * @summary Get metric by ID
         * @param {string} metricId Unique identifier of the metric
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMetric: async (metricId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'metricId' is not null or undefined
            assertParamExists('getMetric', 'metricId', metricId)
            const localVarPath = `/metrics/{metric_id}`
                .replace(`{${"metric_id"}}`, encodeURIComponent(String(metricId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a list of all metrics that have evaluation reports in the system. Useful for building metric selection interfaces. 
         * @summary List available metrics
         * @param {number} [limit] Maximum number of items to return
         * @param {number} [offset] Number of items to skip for pagination
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listMetrics: async (limit?: number, offset?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/metrics`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MetricsApi - functional programming interface
 * @export
 */
export const MetricsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MetricsApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieve a specific metric by its unique identifier. 
         * @summary Get metric by ID
         * @param {string} metricId Unique identifier of the metric
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMetric(metricId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MetricDefinitionschema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMetric(metricId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MetricsApi.getMetric']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve a list of all metrics that have evaluation reports in the system. Useful for building metric selection interfaces. 
         * @summary List available metrics
         * @param {number} [limit] Maximum number of items to return
         * @param {number} [offset] Number of items to skip for pagination
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listMetrics(limit?: number, offset?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MetricsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listMetrics(limit, offset, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MetricsApi.listMetrics']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * MetricsApi - factory interface
 * @export
 */
export const MetricsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MetricsApiFp(configuration)
    return {
        /**
         * Retrieve a specific metric by its unique identifier. 
         * @summary Get metric by ID
         * @param {string} metricId Unique identifier of the metric
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMetric(metricId: string, options?: RawAxiosRequestConfig): AxiosPromise<MetricDefinitionschema> {
            return localVarFp.getMetric(metricId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a list of all metrics that have evaluation reports in the system. Useful for building metric selection interfaces. 
         * @summary List available metrics
         * @param {number} [limit] Maximum number of items to return
         * @param {number} [offset] Number of items to skip for pagination
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listMetrics(limit?: number, offset?: number, options?: RawAxiosRequestConfig): AxiosPromise<MetricsResponse> {
            return localVarFp.listMetrics(limit, offset, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MetricsApi - object-oriented interface
 * @export
 * @class MetricsApi
 * @extends {BaseAPI}
 */
export class MetricsApi extends BaseAPI {
    /**
     * Retrieve a specific metric by its unique identifier. 
     * @summary Get metric by ID
     * @param {string} metricId Unique identifier of the metric
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetricsApi
     */
    public getMetric(metricId: string, options?: RawAxiosRequestConfig) {
        return MetricsApiFp(this.configuration).getMetric(metricId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a list of all metrics that have evaluation reports in the system. Useful for building metric selection interfaces. 
     * @summary List available metrics
     * @param {number} [limit] Maximum number of items to return
     * @param {number} [offset] Number of items to skip for pagination
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetricsApi
     */
    public listMetrics(limit?: number, offset?: number, options?: RawAxiosRequestConfig) {
        return MetricsApiFp(this.configuration).listMetrics(limit, offset, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ModelCardsApi - axios parameter creator
 * @export
 */
export const ModelCardsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieve a list of model cards with flexible filtering. Supports filtering by model name, evaluation date range, task type, metrics, dtype, and other criteria. 
         * @summary List model cards
         * @param {string} [modelName] Filter by model name
         * @param {string} [tasks] Filter by tasks
         * @param {string} [metrics] Filter by metrics
         * @param {number} [limit] Maximum number of items to return
         * @param {number} [offset] Number of items to skip for pagination
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listModelCards: async (modelName?: string, tasks?: string, metrics?: string, limit?: number, offset?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/model-cards`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (modelName !== undefined) {
                localVarQueryParameter['model_name'] = modelName;
            }

            if (tasks !== undefined) {
                localVarQueryParameter['tasks'] = tasks;
            }

            if (metrics !== undefined) {
                localVarQueryParameter['metrics'] = metrics;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ModelCardsApi - functional programming interface
 * @export
 */
export const ModelCardsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ModelCardsApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieve a list of model cards with flexible filtering. Supports filtering by model name, evaluation date range, task type, metrics, dtype, and other criteria. 
         * @summary List model cards
         * @param {string} [modelName] Filter by model name
         * @param {string} [tasks] Filter by tasks
         * @param {string} [metrics] Filter by metrics
         * @param {number} [limit] Maximum number of items to return
         * @param {number} [offset] Number of items to skip for pagination
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listModelCards(modelName?: string, tasks?: string, metrics?: string, limit?: number, offset?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ModelCardsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listModelCards(modelName, tasks, metrics, limit, offset, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ModelCardsApi.listModelCards']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ModelCardsApi - factory interface
 * @export
 */
export const ModelCardsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ModelCardsApiFp(configuration)
    return {
        /**
         * Retrieve a list of model cards with flexible filtering. Supports filtering by model name, evaluation date range, task type, metrics, dtype, and other criteria. 
         * @summary List model cards
         * @param {string} [modelName] Filter by model name
         * @param {string} [tasks] Filter by tasks
         * @param {string} [metrics] Filter by metrics
         * @param {number} [limit] Maximum number of items to return
         * @param {number} [offset] Number of items to skip for pagination
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listModelCards(modelName?: string, tasks?: string, metrics?: string, limit?: number, offset?: number, options?: RawAxiosRequestConfig): AxiosPromise<ModelCardsResponse> {
            return localVarFp.listModelCards(modelName, tasks, metrics, limit, offset, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ModelCardsApi - object-oriented interface
 * @export
 * @class ModelCardsApi
 * @extends {BaseAPI}
 */
export class ModelCardsApi extends BaseAPI {
    /**
     * Retrieve a list of model cards with flexible filtering. Supports filtering by model name, evaluation date range, task type, metrics, dtype, and other criteria. 
     * @summary List model cards
     * @param {string} [modelName] Filter by model name
     * @param {string} [tasks] Filter by tasks
     * @param {string} [metrics] Filter by metrics
     * @param {number} [limit] Maximum number of items to return
     * @param {number} [offset] Number of items to skip for pagination
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ModelCardsApi
     */
    public listModelCards(modelName?: string, tasks?: string, metrics?: string, limit?: number, offset?: number, options?: RawAxiosRequestConfig) {
        return ModelCardsApiFp(this.configuration).listModelCards(modelName, tasks, metrics, limit, offset, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ModelsApi - axios parameter creator
 * @export
 */
export const ModelsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieve a specific model by its unique identifier. 
         * @summary Get model by ID
         * @param {string} modelId Unique identifier of the model
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getModel: async (modelId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'modelId' is not null or undefined
            assertParamExists('getModel', 'modelId', modelId)
            const localVarPath = `/models/{model_id}`
                .replace(`{${"model_id"}}`, encodeURIComponent(String(modelId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a list of all models that have evaluation reports in the system. Useful for building model selection interfaces. 
         * @summary List available models
         * @param {string} [source] Filter by model source/organization
         * @param {number} [limit] Maximum number of items to return
         * @param {number} [offset] Number of items to skip for pagination
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listModels: async (source?: string, limit?: number, offset?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/models`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (source !== undefined) {
                localVarQueryParameter['source'] = source;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ModelsApi - functional programming interface
 * @export
 */
export const ModelsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ModelsApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieve a specific model by its unique identifier. 
         * @summary Get model by ID
         * @param {string} modelId Unique identifier of the model
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getModel(modelId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ModelInfoschema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getModel(modelId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ModelsApi.getModel']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve a list of all models that have evaluation reports in the system. Useful for building model selection interfaces. 
         * @summary List available models
         * @param {string} [source] Filter by model source/organization
         * @param {number} [limit] Maximum number of items to return
         * @param {number} [offset] Number of items to skip for pagination
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listModels(source?: string, limit?: number, offset?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ModelsInfoResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listModels(source, limit, offset, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ModelsApi.listModels']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ModelsApi - factory interface
 * @export
 */
export const ModelsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ModelsApiFp(configuration)
    return {
        /**
         * Retrieve a specific model by its unique identifier. 
         * @summary Get model by ID
         * @param {string} modelId Unique identifier of the model
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getModel(modelId: string, options?: RawAxiosRequestConfig): AxiosPromise<ModelInfoschema> {
            return localVarFp.getModel(modelId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a list of all models that have evaluation reports in the system. Useful for building model selection interfaces. 
         * @summary List available models
         * @param {string} [source] Filter by model source/organization
         * @param {number} [limit] Maximum number of items to return
         * @param {number} [offset] Number of items to skip for pagination
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listModels(source?: string, limit?: number, offset?: number, options?: RawAxiosRequestConfig): AxiosPromise<ModelsInfoResponse> {
            return localVarFp.listModels(source, limit, offset, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ModelsApi - object-oriented interface
 * @export
 * @class ModelsApi
 * @extends {BaseAPI}
 */
export class ModelsApi extends BaseAPI {
    /**
     * Retrieve a specific model by its unique identifier. 
     * @summary Get model by ID
     * @param {string} modelId Unique identifier of the model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ModelsApi
     */
    public getModel(modelId: string, options?: RawAxiosRequestConfig) {
        return ModelsApiFp(this.configuration).getModel(modelId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a list of all models that have evaluation reports in the system. Useful for building model selection interfaces. 
     * @summary List available models
     * @param {string} [source] Filter by model source/organization
     * @param {number} [limit] Maximum number of items to return
     * @param {number} [offset] Number of items to skip for pagination
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ModelsApi
     */
    public listModels(source?: string, limit?: number, offset?: number, options?: RawAxiosRequestConfig) {
        return ModelsApiFp(this.configuration).listModels(source, limit, offset, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ReportsApi - axios parameter creator
 * @export
 */
export const ReportsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieve a specific evaluation report by its unique identifier. Returns the complete report including context, tasks, and results. 
         * @summary Get evaluation report by ID
         * @param {string} reportId Unique identifier of the report
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReport: async (reportId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'reportId' is not null or undefined
            assertParamExists('getReport', 'reportId', reportId)
            const localVarPath = `/reports/{report_id}`
                .replace(`{${"report_id"}}`, encodeURIComponent(String(reportId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ReportsApi - functional programming interface
 * @export
 */
export const ReportsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ReportsApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieve a specific evaluation report by its unique identifier. Returns the complete report including context, tasks, and results. 
         * @summary Get evaluation report by ID
         * @param {string} reportId Unique identifier of the report
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getReport(reportId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Reportschema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getReport(reportId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ReportsApi.getReport']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ReportsApi - factory interface
 * @export
 */
export const ReportsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ReportsApiFp(configuration)
    return {
        /**
         * Retrieve a specific evaluation report by its unique identifier. Returns the complete report including context, tasks, and results. 
         * @summary Get evaluation report by ID
         * @param {string} reportId Unique identifier of the report
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReport(reportId: string, options?: RawAxiosRequestConfig): AxiosPromise<Reportschema> {
            return localVarFp.getReport(reportId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ReportsApi - object-oriented interface
 * @export
 * @class ReportsApi
 * @extends {BaseAPI}
 */
export class ReportsApi extends BaseAPI {
    /**
     * Retrieve a specific evaluation report by its unique identifier. Returns the complete report including context, tasks, and results. 
     * @summary Get evaluation report by ID
     * @param {string} reportId Unique identifier of the report
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReportsApi
     */
    public getReport(reportId: string, options?: RawAxiosRequestConfig) {
        return ReportsApiFp(this.configuration).getReport(reportId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * TasksApi - axios parameter creator
 * @export
 */
export const TasksApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieve a specific task by its unique identifier. 
         * @summary Get task by ID
         * @param {string} taskId Unique identifier of the task
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTask: async (taskId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'taskId' is not null or undefined
            assertParamExists('getTask', 'taskId', taskId)
            const localVarPath = `/tasks/{task_id}`
                .replace(`{${"task_id"}}`, encodeURIComponent(String(taskId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a list of all evaluation tasks available in the system. Useful for building task selection interfaces. 
         * @summary List available tasks
         * @param {number} [limit] Maximum number of items to return
         * @param {number} [offset] Number of items to skip for pagination
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTasks: async (limit?: number, offset?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/tasks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TasksApi - functional programming interface
 * @export
 */
export const TasksApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TasksApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieve a specific task by its unique identifier. 
         * @summary Get task by ID
         * @param {string} taskId Unique identifier of the task
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTask(taskId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TaskDefinitionschema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTask(taskId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TasksApi.getTask']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve a list of all evaluation tasks available in the system. Useful for building task selection interfaces. 
         * @summary List available tasks
         * @param {number} [limit] Maximum number of items to return
         * @param {number} [offset] Number of items to skip for pagination
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listTasks(limit?: number, offset?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TasksResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listTasks(limit, offset, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TasksApi.listTasks']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * TasksApi - factory interface
 * @export
 */
export const TasksApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TasksApiFp(configuration)
    return {
        /**
         * Retrieve a specific task by its unique identifier. 
         * @summary Get task by ID
         * @param {string} taskId Unique identifier of the task
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTask(taskId: string, options?: RawAxiosRequestConfig): AxiosPromise<TaskDefinitionschema> {
            return localVarFp.getTask(taskId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a list of all evaluation tasks available in the system. Useful for building task selection interfaces. 
         * @summary List available tasks
         * @param {number} [limit] Maximum number of items to return
         * @param {number} [offset] Number of items to skip for pagination
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTasks(limit?: number, offset?: number, options?: RawAxiosRequestConfig): AxiosPromise<TasksResponse> {
            return localVarFp.listTasks(limit, offset, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TasksApi - object-oriented interface
 * @export
 * @class TasksApi
 * @extends {BaseAPI}
 */
export class TasksApi extends BaseAPI {
    /**
     * Retrieve a specific task by its unique identifier. 
     * @summary Get task by ID
     * @param {string} taskId Unique identifier of the task
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TasksApi
     */
    public getTask(taskId: string, options?: RawAxiosRequestConfig) {
        return TasksApiFp(this.configuration).getTask(taskId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a list of all evaluation tasks available in the system. Useful for building task selection interfaces. 
     * @summary List available tasks
     * @param {number} [limit] Maximum number of items to return
     * @param {number} [offset] Number of items to skip for pagination
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TasksApi
     */
    public listTasks(limit?: number, offset?: number, options?: RawAxiosRequestConfig) {
        return TasksApiFp(this.configuration).listTasks(limit, offset, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ThresholdsApi - axios parameter creator
 * @export
 */
export const ThresholdsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieve performance thresholds for multiple tasks and metrics in a single request. Useful for interpreting metric results across multiple tasks in a report. Supports filtering by specific tasks and metrics. 
         * @summary Get thresholds for multiple tasks and metrics
         * @param {string} tasks Comma-separated list of task IDs to get thresholds for
         * @param {string} [metrics] Comma-separated list of metric IDs to filter by (optional)
         * @param {number} [limit] Maximum number of items to return
         * @param {number} [offset] Number of items to skip for pagination
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getThresholds: async (tasks: string, metrics?: string, limit?: number, offset?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tasks' is not null or undefined
            assertParamExists('getThresholds', 'tasks', tasks)
            const localVarPath = `/thresholds`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (tasks !== undefined) {
                localVarQueryParameter['tasks'] = tasks;
            }

            if (metrics !== undefined) {
                localVarQueryParameter['metrics'] = metrics;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ThresholdsApi - functional programming interface
 * @export
 */
export const ThresholdsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ThresholdsApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieve performance thresholds for multiple tasks and metrics in a single request. Useful for interpreting metric results across multiple tasks in a report. Supports filtering by specific tasks and metrics. 
         * @summary Get thresholds for multiple tasks and metrics
         * @param {string} tasks Comma-separated list of task IDs to get thresholds for
         * @param {string} [metrics] Comma-separated list of metric IDs to filter by (optional)
         * @param {number} [limit] Maximum number of items to return
         * @param {number} [offset] Number of items to skip for pagination
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getThresholds(tasks: string, metrics?: string, limit?: number, offset?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ThresholdsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getThresholds(tasks, metrics, limit, offset, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ThresholdsApi.getThresholds']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ThresholdsApi - factory interface
 * @export
 */
export const ThresholdsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ThresholdsApiFp(configuration)
    return {
        /**
         * Retrieve performance thresholds for multiple tasks and metrics in a single request. Useful for interpreting metric results across multiple tasks in a report. Supports filtering by specific tasks and metrics. 
         * @summary Get thresholds for multiple tasks and metrics
         * @param {string} tasks Comma-separated list of task IDs to get thresholds for
         * @param {string} [metrics] Comma-separated list of metric IDs to filter by (optional)
         * @param {number} [limit] Maximum number of items to return
         * @param {number} [offset] Number of items to skip for pagination
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getThresholds(tasks: string, metrics?: string, limit?: number, offset?: number, options?: RawAxiosRequestConfig): AxiosPromise<ThresholdsResponse> {
            return localVarFp.getThresholds(tasks, metrics, limit, offset, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ThresholdsApi - object-oriented interface
 * @export
 * @class ThresholdsApi
 * @extends {BaseAPI}
 */
export class ThresholdsApi extends BaseAPI {
    /**
     * Retrieve performance thresholds for multiple tasks and metrics in a single request. Useful for interpreting metric results across multiple tasks in a report. Supports filtering by specific tasks and metrics. 
     * @summary Get thresholds for multiple tasks and metrics
     * @param {string} tasks Comma-separated list of task IDs to get thresholds for
     * @param {string} [metrics] Comma-separated list of metric IDs to filter by (optional)
     * @param {number} [limit] Maximum number of items to return
     * @param {number} [offset] Number of items to skip for pagination
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ThresholdsApi
     */
    public getThresholds(tasks: string, metrics?: string, limit?: number, offset?: number, options?: RawAxiosRequestConfig) {
        return ThresholdsApiFp(this.configuration).getThresholds(tasks, metrics, limit, offset, options).then((request) => request(this.axios, this.basePath));
    }
}



